//
// ********************************************************************
// * License and Disclaimer                                           *
// *                                                                  *
// * The  Geant4 software  is  copyright of the Copyright Holders  of *
// * the Geant4 Collaboration.  It is provided  under  the terms  and *
// * conditions of the Geant4 Software License,  included in the file *
// * LICENSE and available at  http://cern.ch/geant4/license .  These *
// * include a list of copyright holders.                             *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.  Please see the license in the file  LICENSE  and URL above *
// * for the full disclaimer and the limitation of liability.         *
// *                                                                  *
// * This  code  implementation is the result of  the  scientific and *
// * technical work of the GEANT4 collaboration.                      *
// * By using,  copying,  modifying or  distributing the software (or *
// * any work based  on the software)  you  agree  to acknowledge its *
// * use  in  resulting  scientific  publications,  and indicate your *
// * acceptance of all terms of the Geant4 Software license.          *
// ********************************************************************
//
//
// $Id: ExTGDetectorConstructionWithSD.cc,v 1.2 2008/12/18 12:56:52 gunter Exp $
// GEANT4 tag $Name: geant4-09-02 $
//
// ---------------------------------------------------------------------------
 
#include "ExTGDetectorConstructionWithSD.hh"
#include "mySensitiveDetector.hh"
#include "windowSensitiveDetector.hh"

#include "G4LogicalVolume.hh"
#include "G4SDManager.hh"

#include "G4tgbVolumeMgr.hh"
#include "G4tgrMessenger.hh"

#include "myMagneticField.hh"

#include "G4FieldManager.hh"
#include "G4TransportationManager.hh"
#include "G4PropagatorInField.hh"
#include "G4UserLimits.hh"
#include "G4UnitsTable.hh"

// ---------------------------------------------------------------------------
ExTGDetectorConstructionWithSD::ExTGDetectorConstructionWithSD()
{
  messenger = new G4tgrMessenger;
}

ExTGDetectorConstructionWithSD::~ExTGDetectorConstructionWithSD()
{
  delete messenger;
}

// ---------------------------------------------------------------------------
G4VPhysicalVolume* ExTGDetectorConstructionWithSD::Construct()
{
  //------------------------------------------------ 
  // Define one or several text files containing the geometry description
  //------------------------------------------------ 
  G4String filename = "geom.txt";
  G4tgbVolumeMgr* volmgr = G4tgbVolumeMgr::GetInstance();
  volmgr->AddTextFile(filename);

  //------------------------------------------------ 
  // Read the text files and construct the GEANT4 geometry
  //------------------------------------------------ 
  G4VPhysicalVolume* physiWorld = volmgr->ReadAndConstructDetector();

  //------------------------------------------------ 
  // Sensitive detectors
  //------------------------------------------------ 

  G4SDManager* SDman = G4SDManager::GetSDMpointer();
  
  G4String SDname = "/Detector";
  mySensitiveDetector *SD = new mySensitiveDetector(SDname);
  SDman->AddNewDetector(SD);
  SDman->Activate(SDname,true );
  
  G4LogicalVolume * logicDetector =
    G4tgbVolumeMgr::GetInstance()->FindG4LogVol("SiLi",0);
  if(logicDetector)
  {
    logicDetector->SetSensitiveDetector( SD );
  }
  else
  {
    G4Exception("ExTGDetectorConstructionWithSD::Construct()",
                "InvalidGeometry", JustWarning,
                "Volume does not exists in geometry: SiLi.");
  }

  logicDetector = G4tgbVolumeMgr::GetInstance()->FindG4LogVol("window",0);
  if(logicDetector)
  {
    G4String SDname = "/window";
    windowSensitiveDetector *SD = new windowSensitiveDetector(SDname);
    SDman->AddNewDetector(SD);
    SDman->Activate(SDname,true );
    logicDetector->SetSensitiveDetector( SD );
  }
  else
  {
    G4Exception("ExTGDetectorConstructionWithSD::Construct()",
                "InvalidGeometry", JustWarning,
                "Volume does not exists in geometry: window.");
  }

  //Magnetic field
  //  AssignMagneticField();

  return physiWorld;
}
// ---------------------------------------------------------------------------
void
ExTGDetectorConstructionWithSD::AssignMagneticField()
{
  //Get the magnetic field region from the text geometry manager
  G4LogicalVolume * lMagnetRegion = G4tgbVolumeMgr::GetInstance()->FindG4LogVol("lMagnetRegion",0);
  if(!lMagnetRegion)
  {
    G4Exception("ExTGDetectorConstructionWithSD::AssignMagneticField()",
                " InvalidGeometry ",JustWarning,
                " Volume does not exists in geometry: lMagnetRegion");
    return;
  }


  // assign magnetic field to the region inside the magnet  
  myMagneticField *magField = new myMagneticField();
  magField->SetFieldValue(0.2*tesla);

  G4FieldManager*    fFieldMgr = new G4FieldManager(magField);
  fFieldMgr->SetDetectorField(magField);
  G4double stepMinimum = 0.1*mm;
  G4ChordFinder *chordFinder = new G4ChordFinder(magField, stepMinimum);
  fFieldMgr->SetChordFinder(chordFinder);
  //  fFieldMgr->CreateChordFinder(magField);
  lMagnetRegion->SetFieldManager(fFieldMgr, true);        
  // Some debugging values
  fFieldMgr->SetDeltaIntersection(1.0e-6*mm);
  fFieldMgr->SetDeltaOneStep(1.0e-6*mm);
  G4cout << "fieldDeltaIntersection (mm) " << fFieldMgr->GetDeltaIntersection()/mm << endl;
  G4cout << "fieldDeltaOneStep (mm) " << fFieldMgr->GetDeltaOneStep()/mm << endl;
  G4cout << "fieldMinimumEpsilonStep" << fFieldMgr->GetMinimumEpsilonStep()<< endl;
  G4cout << "fieldMaximumEpsilonStep" << fFieldMgr->GetMaximumEpsilonStep()<< endl;
  
  
  // to allow smooth viewing of path in magnetic field
  G4TransportationManager* tmanager = G4TransportationManager::GetTransportationManager();
  tmanager->GetPropagatorInField()->SetLargestAcceptableStep(2*mm);

  //Set a limit on the track length so that a particle does not rotate forever in the magnetic field
  G4double maxStep = 1*m;
  G4double maxLength = 10*m;
  lMagnetRegion->SetUserLimits(new G4UserLimits(maxStep, maxLength));

  return;

}
